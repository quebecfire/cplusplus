//
// Created by Vincent Morin on 2021-12-20.
//

/* Inline Function
 * Invoking a function automatically implies some overhead
 * The overhead is generated by the need of going from one memory address to the other
 * Also after completed the function execution, it needs to return to the proper code path
 * It then needs to store the return address.
 *
 * One of the way to remove the overhead associated with the function call is to define a macro
 * But one of the macro problem is the fact that it will take the parameters "as is" and expand it textually
 *
 * C++ is offering another way to remove this overhead. It's called inlining
 *
 * A function that is marked with inline keyword
 * Such function are normally defined in header file
 * This request the compiler to replace the call with the function body
 * Remember this is a just a request, it could be ignored by your compiler
 * Certains functions may not be inlined
 *  - large functions
 *  - functions having too many conditionals statements
 *  - recursive functions
 *  - functions invoked through pointers
 *  - etc
 *
 *  Different compilers have a different set of rules
 *  Modern compilers may automatically inline even non-inline functions
 *
 *  Excessive inlining will eventually end in a bigger binary
 */

#include <iostream>

inline int Square(int x) {
    return x * x;
}

#define  SquareMacro(x) x*x

int main() {
    using namespace std;
    int val = 5;
    int result = SquareMacro(val); // Here the macro is expanded to val * val
    cout << result << endl;

    result = SquareMacro(val + 1); // Here the macro is expanded to val + (1 * val) + 1 so the value will not be right
    cout << result << endl;

    result = Square(val);
    cout << result << endl;
    return 0;
}